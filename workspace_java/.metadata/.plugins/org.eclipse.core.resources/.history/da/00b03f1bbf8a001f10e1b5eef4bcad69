package jdbc.day02;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Scanner;

/*		== HR에서 예전에 생성해두었던 pcd_tbl_member_test1_insert 프로시저 을 사용해본다.
 create or replace procedure  pcd_tbl_member_test1_insert(p_id varchar2, p_pwd varchar2, p_name varchar2)
    is
        error_input     exception;
        error_dayTime   exception;
        number_cnt      number(2) := 0;
        char_cnt        number(2) := 0;
        special_cnt     number(2) := 0;
    begin
    
        --입력(insert)이 불가한 요일명과 시간대를 알아봅시다. --
        if(to_char(sysdate, 'd') in ('1', '7') or
            to_number(to_char(sysdate, 'hh24')) <14 or
            to_number(to_char(sysdate, 'hh24')) >16 )then
            raise error_dayTime;
        
        -- 입력(insert)이 가능한 요일명과 시간대 이라면 암호를 검사하겠다.
        else
            if
                length(p_pwd) > 20 or length(p_pwd)< 5 then
                raise error_input;
            end if;
            
            for i in 1..length(p_pwd) loop
                if ascii(substr(p_pwd, i, 1)) > 127 then raise error_input;
                elsif substr(p_pwd, i, 1) between 'A' and 'Z' then char_cnt := char_cnt + 1;
                elsif substr(p_pwd, i, 1) between 'a' and 'z' then char_cnt := char_cnt + 1;
                elsif substr(p_pwd, i, 1) between '0' and '9' then number_cnt := number_cnt + 1;
                else special_cnt := special_cnt + 1;
                end if;
            end loop;
            
            if
                (number_cnt = 0) or (char_cnt = 0) or (special_cnt = 0) then
                raise error_input;
            else 
                insert into tbl_member_test1(userid, passwd, name) values (p_id, p_pwd, p_name);
            end if;
        end if;
         
    exception
        when error_dayTime then
        raise_application_error(-20003, '>> 영업시간(월~금 14:00 ~ 16:59:59 까지)이 아니므로 입력불가함!! <<');
        when error_input then
        raise_application_error(-20002, '암호는 최소 5글자 이상 20글자 이하의 영문자 및 숫자 및 특수기호가 혼합되어져야 합니다');
    end pcd_tbl_member_test1_insert; 
 
 */


public class Procedure_insert_sqlexception_CallableStatement_04 {

	public static void main(String[] args) {
		
		Connection conn = null;

		CallableStatement cstmt = null;
		// CallableStatement cstmt 은 Connection conn(연결한 DB 서버)에 존재하는 Procedure 를 호출해주는 객체(우편배달부)이다.
		
		try {
			Class.forName("oracle.jdbc.driver.OracleDriver");
			

			conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:xe", "JDBC_USER", "gclass");
			
			
			// >>> 3. Connection conn 객체를 사용하여 prepareCall() 메소드를 호출함으로써
	        //        CallableStatement cstmt 객체를 생성한다.
	        //        즉, 우편배달부(택배기사) 객체 만들기
			cstmt = conn.prepareCall("{call pcd_tbl_member_test1_insert(?, ?, ?)}");
			/*
				 오라클 서버에 생성한 프로시저 pcd_student_select_one 의 
            	 매개변수 갯수가 2개 이므로 ? 를 2개 준다.
            	 
            	 다음으로 오라클의 프로시저를 수행( executeUpdate() 또는 execute() ) 하기에 앞서서  
				반드시 해야할 일은 IN mode 로 되어진 파라미터에 값을 넣어주고,
				OUT mode 로 설정된 곳에 그 결과값을 받아오도록 아래와 같이 설정해야 한다.
				
				프로시저의 IN mode 로 되어진 파라미터에 값을 넣어줄때는 
				cstmt.setXXX() 메소드를 사용한다. 
					 
			 */
			
			Scanner sc = new Scanner(System.in);
			System.out.print("😐 아이디 : ");
			String userid = sc.nextLine();	//서울 강남구
			
			System.out.print("😐 비밀번호 : ");
			String passwd = sc.nextLine();	//서울 강남구
			
			System.out.print("😐 성명 : ");
			String name = sc.nextLine();	//서울 강남구
			
			cstmt.setString(1, userid); // 숫자 1 은 프로시저 파라미터중 첫번째 파라미터인 IN 모드의 ? 를 말한다.
			cstmt.setString(2, passwd); // 숫자 1 은 프로시저 파라미터중 두번째 파라미터인 IN 모드의 ? 를 말한다.
			cstmt.setString(3, name); 	// 숫자 1 은 프로시저 파라미터중 세번째 파라미터인 IN 모드의 ? 를 말한다.
			
			// >>> 4. CallableStatement cstmt 객체를 사용하여 오라클의 프로시저 실행하기  <<<
			//cstmt.execute();		//오라클 서버에게 해당 프로시저를 실행해라는 것이다.
			//또는
			int n = cstmt.executeUpdate();	//오라클 서버에게 해당 프로시저를 실행해라는 것이다.
			
			rs = (ResultSet) cstmt.getObject(2);
			// 여기서 숫자 2는 프로시저의 파라미터 순서를 말한다.
			// 즉, 2번째 파라미터에 저장되어진 정보를 꺼내오는데 리턴타입이 Object 이다.
			// 여기서 2번째 파라미터는 CURSOR로 되어진 OUT 모드이며 select 되어진 결과물이다.
			// 그러므로 Object 타입으로 리턴된 것을 ResultSet 타입으로 casting(강제형변환)시켜야 한다.
			
			StringBuilder sb = new StringBuilder();
			
			
			int cnt = 0;
			
			while (rs.next()) {
				cnt ++;
				if(cnt == 1) {
					sb.append("-".repeat(80) + "\n");
					sb.append("학번\t성명\t연락처\t\t주소\t\t입력일자\t\t학급번호\t학급명\t\t담임명\n");
					sb.append("-".repeat(80) + "\n");	
				}
				//stno, name, tel, addr, to_char(registerdate, 'yyyy-mm-dd') as registerday, fk_classno, classname, teachername

				sb.append(rs.getInt("stno") + "\t");
				sb.append(rs.getString("name")+ "\t");
				sb.append(rs.getString("tel")+ "\t");
				sb.append(rs.getString("addr")+ "\t");
				sb.append(rs.getString("registerday")+ "\t");
				sb.append(rs.getInt("fk_classno")+ "\t");
				sb.append(rs.getString("classname")+ "\t");
				sb.append(rs.getString("teachername")+ "\n");
			}// end of while------------------------------------------
			
			if(cnt == 0) {
				System.out.println(">>>검색하신 주소에 " + searchAddr + "는 없습니다!!!<<<");
			}
			else {
				System.out.println(sb.toString());
			}
			
			
			
			sc.close();

		} catch (ClassNotFoundException e) {
			System.out.println(">>> ojdbc8.jar 파일이 없습니다. <<<");
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			try {
				if(rs != null) {
					rs.close();
					rs = null;
				}

				if (cstmt != null) {
					cstmt.close();
					cstmt = null;
				}

				if (conn != null) {
					conn.close();
					conn = null;
				}

			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

		System.out.println("(((o(*ﾟ▽ﾟ*)o)))프로그램 종료");


	}

}
